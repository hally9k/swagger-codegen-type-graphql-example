/**
 * Tether API V2
 *   An _Installation_ has many _InstallationLocations_. Each _InstallationLocation_ has one active _DeviceAssignment_. Each _DeviceAssigment_ has a link to a physical Tether _Device_.   ## Installation This is the top level for a property / address. An individual house, apartment, office.  ## InstallationLocation A single location inside your Installation. Usually a single room like Kitchen, Lounge, Master Bedroom. This is the endpoint that collects metrics that the devices log.  You associate a Device to an InstallationLocation. Then you can query this InstallationLocation to retrieve all the readings/samples. If you need to remove a device you can still query this InstallationLocation to retrieve all historic readings. If you replace a device the readings will continue.  ### Reading vs Sample We have two ways of working with the metrics received from our devices. Readings and Samples.  **Samples** These are structures that have an object for a single payload received from a device. These are ordered by most recent first. ``` [     {         \"deviceId\": \"9c9a4097-62b9-4fee-93c5-a8401dbba9d6\",         \"timestamp\": \"2019-03-25T02:31:36.000Z\",         \"sample\": {             \"temperature\": 23.77,             \"humidity\": 52,             \"battery\": 95         }     },     {         \"deviceId\": \"9c9a4097-62b9-4fee-93c5-a8401dbba9d6\",         \"timestamp\": \"2019-03-25T02:30:36.000Z\",         \"sample\": {             \"temperature\": 24.45,             \"humidity\": 51,             \"battery\": 95         }     } ] ```  **Readings** These have each metric split up into arrays, and inside each metric array is a [key,value] pair which represents the timestamp (unix timestamp in seconds) when it was received and the value at that time. These are ordered by time received. ``` {     \"temperature\": [ [1553481036, 24.45], [1553481096, 23.77] ],     \"humidity\": [ [1553481036, 51], [1553481096, 52] ],     \"battery\": [ [1553481036, 95], [1553481096, 95] ] } ```  ## Device Assignment Links a physical Device to a physical room (InstallationLocation).  ## Device A physical Tether Device.
 *
 * OpenAPI spec version: 2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require("request");
import http = require("http");
import Promise = require("bluebird");

let defaultBasePath = "https://api.staging.tetherme.io/v2/";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any"
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type
        );
      }
      return instance;
    }
  }
}

export class CreateDeviceAssignment {
  /**
   * ID of the location this belongs to
   */
  "installationLocationId": string;
  /**
   * serial (QR Code) of the physical device
   */
  "deviceSerial"?: string;
  /**
   * ID of the PowerQCircuit to assign
   */
  "powerqCircuitId"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "installationLocationId",
      baseName: "installationLocationId",
      type: "string"
    },
    {
      name: "deviceSerial",
      baseName: "deviceSerial",
      type: "string"
    },
    {
      name: "powerqCircuitId",
      baseName: "powerqCircuitId",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return CreateDeviceAssignment.attributeTypeMap;
  }
}

export class CreateUser {
  /**
   * First name of the user
   */
  "firstName": string;
  /**
   * Last name of the user
   */
  "lastName": string;
  /**
   * Email of the user - this needs to be unique
   */
  "email": string;
  /**
   * Password to set for the user to log in
   */
  "password": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "firstName",
      baseName: "firstName",
      type: "string"
    },
    {
      name: "lastName",
      baseName: "lastName",
      type: "string"
    },
    {
      name: "email",
      baseName: "email",
      type: "string"
    },
    {
      name: "password",
      baseName: "password",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return CreateUser.attributeTypeMap;
  }
}

export class Device {
  /**
   * ID of the device
   */
  "id": string;
  /**
   * serial on the back of the device
   */
  "serialNumber": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "serialNumber",
      baseName: "serialNumber",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return Device.attributeTypeMap;
  }
}

export class DeviceAssignment {
  /**
   * ID of the device assignment
   */
  "id": string;
  /**
   * ID of the physical device
   */
  "deviceId": string;
  /**
   * ID of the installation this belongs to (DEPRECATED)
   */
  "installationId": string;
  /**
   * ID of the location this belongs to (NEW)
   */
  "installationLocationId": string;
  /**
   * Color (DEPRECATED)
   */
  "color": string;
  /**
   * Label (DEPRECATED)
   */
  "label": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "deviceId",
      baseName: "deviceId",
      type: "string"
    },
    {
      name: "installationId",
      baseName: "installationId",
      type: "string"
    },
    {
      name: "installationLocationId",
      baseName: "installationLocationId",
      type: "string"
    },
    {
      name: "color",
      baseName: "color",
      type: "string"
    },
    {
      name: "label",
      baseName: "label",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return DeviceAssignment.attributeTypeMap;
  }
}

export class DeviceSignal {
  /**
   * time the message was received (UTC)
   */
  "timestamp": string;
  /**
   * human-readable string to indicate signal
   */
  "message": string;
  /**
   * device signal percentage between 0 and 1. 1 is great, 0 is terrible
   */
  "percentage": number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "timestamp",
      baseName: "timestamp",
      type: "string"
    },
    {
      name: "message",
      baseName: "message",
      type: "string"
    },
    {
      name: "percentage",
      baseName: "percentage",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return DeviceSignal.attributeTypeMap;
  }
}

export class Installation {
  /**
   * ID of this installation
   */
  "id": string;
  /**
   * Type of this installation
   */
  "type": string;
  /**
   * The organisation this property belongs to
   */
  "organisationId"?: string;
  /**
   *
   */
  "address1"?: string;
  /**
   *
   */
  "address2"?: string;
  /**
   *
   */
  "addressCity"?: string;
  /**
   *
   */
  "addressCountry"?: string;
  /**
   *
   */
  "addressPostcode"?: string;
  /**
   *
   */
  "latitude"?: string;
  /**
   *
   */
  "longitude"?: string;
  /**
   * Mobile App access code to log in to tenant app
   */
  "accessCode"?: string;
  /**
   * custom ID to assign to this installation
   */
  "customPropertyId"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "type",
      baseName: "type",
      type: "string"
    },
    {
      name: "organisationId",
      baseName: "organisationId",
      type: "string"
    },
    {
      name: "address1",
      baseName: "address1",
      type: "string"
    },
    {
      name: "address2",
      baseName: "address2",
      type: "string"
    },
    {
      name: "addressCity",
      baseName: "addressCity",
      type: "string"
    },
    {
      name: "addressCountry",
      baseName: "addressCountry",
      type: "string"
    },
    {
      name: "addressPostcode",
      baseName: "addressPostcode",
      type: "string"
    },
    {
      name: "latitude",
      baseName: "latitude",
      type: "string"
    },
    {
      name: "longitude",
      baseName: "longitude",
      type: "string"
    },
    {
      name: "accessCode",
      baseName: "accessCode",
      type: "string"
    },
    {
      name: "customPropertyId",
      baseName: "customPropertyId",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return Installation.attributeTypeMap;
  }
}

export class InstallationLocation {
  /**
   * ID (uuid) of this object
   */
  "id": string;
  /**
   * ID (uuid) of Installation this belongs to
   */
  "installationId": string;
  /**
   * Either ROOM or CIRCUIT. Will default to ROOM
   */
  "type": string;
  /**
   * Custom name for this Location. This is unique and case insensitive
   */
  "name": string;
  /**
   * Color to display
   */
  "color": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "installationId",
      baseName: "installationId",
      type: "string"
    },
    {
      name: "type",
      baseName: "type",
      type: "string"
    },
    {
      name: "name",
      baseName: "name",
      type: "string"
    },
    {
      name: "color",
      baseName: "color",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return InstallationLocation.attributeTypeMap;
  }
}

export class InstallationStatus {
  /**
   * Description of the status
   */
  "description": string;
  /**
   * Number between 0 and 1 indicating the score of the installation
   */
  "score": string;
  /**
   * Color indicating the score
   */
  "statusColor": string;
  /**
   * Text label for the status of the installation
   */
  "statusLabel": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "description",
      baseName: "description",
      type: "string"
    },
    {
      name: "score",
      baseName: "score",
      type: "string"
    },
    {
      name: "statusColor",
      baseName: "statusColor",
      type: "string"
    },
    {
      name: "statusLabel",
      baseName: "statusLabel",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return InstallationStatus.attributeTypeMap;
  }
}

export class LoginBody {
  /**
   * [description]
   */
  "email": string;
  /**
   * [description]
   */
  "password": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string"
    },
    {
      name: "password",
      baseName: "password",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return LoginBody.attributeTypeMap;
  }
}

export class LoginBodySuccess {
  /**
   *
   */
  "token": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "token",
      baseName: "token",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return LoginBodySuccess.attributeTypeMap;
  }
}

export class PowerQ {
  /**
   * ID of the PowerQ
   */
  "id": string;
  "circuits"?: Array<PowerQCircuit>;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "circuits",
      baseName: "circuits",
      type: "Array<PowerQCircuit>"
    }
  ];

  static getAttributeTypeMap() {
    return PowerQ.attributeTypeMap;
  }
}

export class PowerQCircuit {
  /**
   * ID of the PowerQCircuit
   */
  "id": string;
  /**
   * ID of the parent PowerQ
   */
  "powerqId": string;
  /**
   * slot (0-based) of this circuit to the PowerQ
   */
  "payloadIndex": number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "powerqId",
      baseName: "powerqId",
      type: "string"
    },
    {
      name: "payloadIndex",
      baseName: "payloadIndex",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return PowerQCircuit.attributeTypeMap;
  }
}

export class Readings {
  "temperature": Array<number>;
  "humidity"?: Array<number>;
  "battery"?: Array<number>;
  "light"?: Array<number>;
  "pressure"?: Array<number>;
  "co2"?: Array<number>;
  "dewPoint"?: Array<number>;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "temperature",
      baseName: "temperature",
      type: "Array<number>"
    },
    {
      name: "humidity",
      baseName: "humidity",
      type: "Array<number>"
    },
    {
      name: "battery",
      baseName: "battery",
      type: "Array<number>"
    },
    {
      name: "light",
      baseName: "light",
      type: "Array<number>"
    },
    {
      name: "pressure",
      baseName: "pressure",
      type: "Array<number>"
    },
    {
      name: "co2",
      baseName: "co2",
      type: "Array<number>"
    },
    {
      name: "dewPoint",
      baseName: "dewPoint",
      type: "Array<number>"
    }
  ];

  static getAttributeTypeMap() {
    return Readings.attributeTypeMap;
  }
}

export class Report {
  /**
   * unique id to get this report
   */
  "id": string;
  /**
   * the type of this report
   */
  "type": string;
  /**
   * SUBMITTED | PROCESSING | ERROR | COMPLETED
   */
  "status": string;
  /**
   * Any further details from the reporting process
   */
  "details"?: string;
  /**
   * any parameters that this report needs
   */
  "parameters": any;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "type",
      baseName: "type",
      type: "string"
    },
    {
      name: "status",
      baseName: "status",
      type: "string"
    },
    {
      name: "details",
      baseName: "details",
      type: "string"
    },
    {
      name: "parameters",
      baseName: "parameters",
      type: "any"
    }
  ];

  static getAttributeTypeMap() {
    return Report.attributeTypeMap;
  }
}

export class ReportRequest {
  /**
   * the type of report to request
   */
  "type": string;
  /**
   * any parameters that this report needs
   */
  "parameters": any;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "string"
    },
    {
      name: "parameters",
      baseName: "parameters",
      type: "any"
    }
  ];

  static getAttributeTypeMap() {
    return ReportRequest.attributeTypeMap;
  }
}

export class Sample {
  /**
   * uuid of device this sample is from
   */
  "deviceId": string;
  /**
   * ISO8601 timestamp of when this sample was taken
   */
  "timestamp": string;
  "sample": SampleV3V4;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "deviceId",
      baseName: "deviceId",
      type: "string"
    },
    {
      name: "timestamp",
      baseName: "timestamp",
      type: "string"
    },
    {
      name: "sample",
      baseName: "sample",
      type: "SampleV3V4"
    }
  ];

  static getAttributeTypeMap() {
    return Sample.attributeTypeMap;
  }
}

export class SampleV3V4 {
  /**
   * either '3' or '4'
   */
  "type": number;
  /**
   * positive integer from 0 to 100 to indicate battery percentage
   */
  "battery": number;
  /**
   * in celsius
   */
  "temperature": number;
  /**
   * relative humidity
   */
  "humidity": number;
  /**
   * lumens
   */
  "light": number;
  /**
   * (only in sample type 3)
   */
  "pressure"?: number;
  /**
   * carbon dioxide (only in sample type 3)
   */
  "co2"?: number;
  /**
   * tvoc (only in sample type 3)
   */
  "tvoc"?: number;
  /**
   * dewpoint
   */
  "dewpoint": number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "number"
    },
    {
      name: "battery",
      baseName: "battery",
      type: "number"
    },
    {
      name: "temperature",
      baseName: "temperature",
      type: "number"
    },
    {
      name: "humidity",
      baseName: "humidity",
      type: "number"
    },
    {
      name: "light",
      baseName: "light",
      type: "number"
    },
    {
      name: "pressure",
      baseName: "pressure",
      type: "number"
    },
    {
      name: "co2",
      baseName: "co2",
      type: "number"
    },
    {
      name: "tvoc",
      baseName: "tvoc",
      type: "number"
    },
    {
      name: "dewpoint",
      baseName: "dewpoint",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return SampleV3V4.attributeTypeMap;
  }
}

export class UpdateUser {
  /**
   * ID of the user. Should not change
   */
  "id": string;
  /**
   * First name of the user
   */
  "firstName": string;
  /**
   * Last name of the user
   */
  "lastName": string;
  /**
   * Email (and login) of user
   */
  "email": string;
  /**
   * URL to image for avatar of user
   */
  "avatarUrl"?: string;
  /**
   * When the user was created
   */
  "createdAt": string;
  /**
   * When the user was last updated
   */
  "updatedAt": string;
  /**
   * Password to set for the user to log in. If this is not passed then the password is not updated.
   */
  "password"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "firstName",
      baseName: "firstName",
      type: "string"
    },
    {
      name: "lastName",
      baseName: "lastName",
      type: "string"
    },
    {
      name: "email",
      baseName: "email",
      type: "string"
    },
    {
      name: "avatarUrl",
      baseName: "avatarUrl",
      type: "string"
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string"
    },
    {
      name: "updatedAt",
      baseName: "updatedAt",
      type: "string"
    },
    {
      name: "password",
      baseName: "password",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return UpdateUser.attributeTypeMap;
  }
}

export class UserOrganisation {
  /**
   * ID of the User
   */
  "userId": string;
  /**
   * ID of the Organisation
   */
  "organisationId": string;
  /**
   * ID of the Role of this User
   */
  "userRoleId": number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "userId",
      baseName: "userId",
      type: "string"
    },
    {
      name: "organisationId",
      baseName: "organisationId",
      type: "string"
    },
    {
      name: "userRoleId",
      baseName: "userRoleId",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return UserOrganisation.attributeTypeMap;
  }
}

export class Weather {
  /**
   * longitude where this reading was taken
   */
  "longitude": string;
  /**
   * latitude where this reading was taken
   */
  "latitude": string;
  /**
   * timestamp when this reading was taken
   */
  "timestamp": string;
  /**
   * temperature
   */
  "temperature": number;
  /**
   * humidity
   */
  "humidity": number;
  /**
   * pressure
   */
  "pressure": number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "longitude",
      baseName: "longitude",
      type: "string"
    },
    {
      name: "latitude",
      baseName: "latitude",
      type: "string"
    },
    {
      name: "timestamp",
      baseName: "timestamp",
      type: "string"
    },
    {
      name: "temperature",
      baseName: "temperature",
      type: "number"
    },
    {
      name: "humidity",
      baseName: "humidity",
      type: "number"
    },
    {
      name: "pressure",
      baseName: "pressure",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return Weather.attributeTypeMap;
  }
}

let enumsMap: { [index: string]: any } = {};

let typeMap: { [index: string]: any } = {
  CreateDeviceAssignment: CreateDeviceAssignment,
  CreateUser: CreateUser,
  Device: Device,
  DeviceAssignment: DeviceAssignment,
  DeviceSignal: DeviceSignal,
  Installation: Installation,
  InstallationLocation: InstallationLocation,
  InstallationStatus: InstallationStatus,
  LoginBody: LoginBody,
  LoginBodySuccess: LoginBodySuccess,
  PowerQ: PowerQ,
  PowerQCircuit: PowerQCircuit,
  Readings: Readings,
  Report: Report,
  ReportRequest: ReportRequest,
  Sample: Sample,
  SampleV3V4: SampleV3V4,
  UpdateUser: UpdateUser,
  UserOrganisation: UserOrganisation,
  Weather: Weather
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = "";

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == "header" &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum AuthApiApiKeys {
  JWT
}

export class AuthApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: AuthApiApiKeys, value: string) {
    (this.authentications as any)[AuthApiApiKeys[key]].apiKey = value;
  }
  /**
   * Authenticate to Tether APIs with email/password
   * @summary username/password
   * @param login [description]
   */
  public authLoginPost(
    login: LoginBody
  ): Promise<{ response: http.ClientResponse; body: LoginBodySuccess }> {
    const localVarPath = this.basePath + "/auth/login";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'login' is not null or undefined
    if (login === null || login === undefined) {
      throw new Error(
        "Required parameter login was null or undefined when calling authLoginPost."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(login, "LoginBody")
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: LoginBodySuccess;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "LoginBodySuccess");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum DeviceApiApiKeys {
  JWT
}

export class DeviceApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DeviceApiApiKeys, value: string) {
    (this.authentications as any)[DeviceApiApiKeys[key]].apiKey = value;
  }
  /**
   * Search for devices
   * @summary Search for devices
   * @param serialNumber serialNumber of device to find
   */
  public deviceGet(
    serialNumber: string
  ): Promise<{ response: http.ClientResponse; body: Array<Device> }> {
    const localVarPath = this.basePath + "/device";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'serialNumber' is not null or undefined
    if (serialNumber === null || serialNumber === undefined) {
      throw new Error(
        "Required parameter serialNumber was null or undefined when calling deviceGet."
      );
    }

    if (serialNumber !== undefined) {
      localVarQueryParameters["serialNumber"] = ObjectSerializer.serialize(
        serialNumber,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<Device> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<Device>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Get device by ID.
   * @summary Get device by ID
   * @param id ID of Device
   */
  public deviceIdGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: Device }> {
    const localVarPath =
      this.basePath +
      "/device/{id}".replace("{" + "id" + "}", encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deviceIdGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Device }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Device");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Get last reading from a device (by ID).
   * @summary Gets last reading from device
   * @param id ID of Device
   */
  public deviceIdLatestGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: Sample }> {
    const localVarPath =
      this.basePath +
      "/device/{id}/latest".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deviceIdLatestGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Sample }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Sample");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Gets the signal strength from a device (by ID).
   * @summary Gets signal strength from device
   * @param id ID of Device
   * @param limit number between 1 and 100 indicating how many results to return. Default 100
   */
  public deviceIdSignalGet(
    id: string,
    limit?: number
  ): Promise<{ response: http.ClientResponse; body: Array<DeviceSignal> }> {
    const localVarPath =
      this.basePath +
      "/device/{id}/signal".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deviceIdSignalGet."
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<DeviceSignal>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<DeviceSignal>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum DeviceAssignmentApiApiKeys {
  JWT
}

export class DeviceAssignmentApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DeviceAssignmentApiApiKeys, value: string) {
    (this.authentications as any)[
      DeviceAssignmentApiApiKeys[key]
    ].apiKey = value;
  }
  /**
   * Search for device assignments assiociated with an installation location
   * @summary Search device assignments
   * @param installationLocationId id of the installation to get locations for
   */
  public deviceassignmentGet(
    installationLocationId: string
  ): Promise<{ response: http.ClientResponse; body: Array<DeviceAssignment> }> {
    const localVarPath = this.basePath + "/deviceassignment/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'installationLocationId' is not null or undefined
    if (
      installationLocationId === null ||
      installationLocationId === undefined
    ) {
      throw new Error(
        "Required parameter installationLocationId was null or undefined when calling deviceassignmentGet."
      );
    }

    if (installationLocationId !== undefined) {
      localVarQueryParameters[
        "installationLocationId"
      ] = ObjectSerializer.serialize(installationLocationId, "string");
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<DeviceAssignment>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<DeviceAssignment>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Deletes existing Device Assignment
   * @summary Delete a device assignment
   * @param id id of the device assignment to delete
   */
  public deviceassignmentIdDelete(
    id: string
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/deviceassignment/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deviceassignmentIdDelete."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Gets a Device Assignment
   * @summary Get device assignment
   * @param id id of the device assignment
   */
  public deviceassignmentIdGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: DeviceAssignment }> {
    const localVarPath =
      this.basePath +
      "/deviceassignment/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deviceassignmentIdGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: DeviceAssignment;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "DeviceAssignment");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Creates a new Device Assignment with a device serial number
   * @summary Create new device assignment
   * @param deviceassignment The new device assignment to create. Must have either deviceSerial OR powerqCircuitId
   */
  public deviceassignmentPost(
    deviceassignment: CreateDeviceAssignment
  ): Promise<{ response: http.ClientResponse; body: DeviceAssignment }> {
    const localVarPath = this.basePath + "/deviceassignment/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'deviceassignment' is not null or undefined
    if (deviceassignment === null || deviceassignment === undefined) {
      throw new Error(
        "Required parameter deviceassignment was null or undefined when calling deviceassignmentPost."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        deviceassignment,
        "CreateDeviceAssignment"
      )
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: DeviceAssignment;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "DeviceAssignment");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum InstallationApiApiKeys {
  JWT
}

export class InstallationApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: InstallationApiApiKeys, value: string) {
    (this.authentications as any)[InstallationApiApiKeys[key]].apiKey = value;
  }
  /**
   * Get all installations
   * @summary Get all installations
   */
  public installationGet(): Promise<{
    response: http.ClientResponse;
    body: Array<Installation>;
  }> {
    const localVarPath = this.basePath + "/installation";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<Installation>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<Installation>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get installation by ID
   * @summary Get installation by ID
   * @param id ID of installation
   */
  public installationIdGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: Installation }> {
    const localVarPath =
      this.basePath +
      "/installation/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationIdGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Installation }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Installation");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Gets the status of an installation
   * @summary Get installation status
   * @param id ID of installation
   */
  public installationIdStatusGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: InstallationStatus }> {
    const localVarPath =
      this.basePath +
      "/installation/{id}/status".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationIdStatusGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: InstallationStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InstallationStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * [EXPERIMENTAL] Create new installation
   * @summary [EXPERIMENTAL] Create new installation
   * @param installation the new object to create
   */
  public installationPost(
    installation: Installation
  ): Promise<{ response: http.ClientResponse; body: Installation }> {
    const localVarPath = this.basePath + "/installation/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'installation' is not null or undefined
    if (installation === null || installation === undefined) {
      throw new Error(
        "Required parameter installation was null or undefined when calling installationPost."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(installation, "Installation")
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Installation }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Installation");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum InstallationLocationApiApiKeys {
  JWT
}

export class InstallationLocationApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: InstallationLocationApiApiKeys, value: string) {
    (this.authentications as any)[
      InstallationLocationApiApiKeys[key]
    ].apiKey = value;
  }
  /**
   * Search for installation locations by installationId
   * @summary Search installation locations
   * @param installationId id of the installation to get locations for
   */
  public installationlocationGet(
    installationId: string
  ): Promise<{
    response: http.ClientResponse;
    body: Array<InstallationLocation>;
  }> {
    const localVarPath = this.basePath + "/installationlocation/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'installationId' is not null or undefined
    if (installationId === null || installationId === undefined) {
      throw new Error(
        "Required parameter installationId was null or undefined when calling installationlocationGet."
      );
    }

    if (installationId !== undefined) {
      localVarQueryParameters["installationId"] = ObjectSerializer.serialize(
        installationId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<InstallationLocation>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "Array<InstallationLocation>"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get installation location by id
   * @summary Get installation location
   * @param id id of the InstallationLocation
   */
  public installationlocationIdGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: InstallationLocation }> {
    const localVarPath =
      this.basePath +
      "/installationlocation/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationlocationIdGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: InstallationLocation;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InstallationLocation");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get installation location power readings. This splits up powers into individual arrays based on the resolution (hourly, daily, monthly). Date range should not be longer than a week for hourly readings. Will only work for CIRCUIT installation location types. Anything else will return a 400 Bad Request.
   * @summary IN DEVELOPMENT - Get smoothed power readings for hours/days/months
   * @param id id of the InstallationLocation
   * @param fromTimestamp ISO8601 timestamp (UTC)
   * @param toTimestamp ISO8601 timestamp (UTC)
   * @param resolution &#39;HOURLY&#39;,&#39;DAILY&#39;, or &#39;MONTHLY&#39;. Defaults to &#39;HOURLY&#39;
   */
  public installationlocationIdPowerGet(
    id: string,
    fromTimestamp: string,
    toTimestamp: string,
    resolution?: string
  ): Promise<{ response: http.ClientResponse; body: Readings }> {
    const localVarPath =
      this.basePath +
      "/installationlocation/{id}/power/".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationlocationIdPowerGet."
      );
    }

    // verify required parameter 'fromTimestamp' is not null or undefined
    if (fromTimestamp === null || fromTimestamp === undefined) {
      throw new Error(
        "Required parameter fromTimestamp was null or undefined when calling installationlocationIdPowerGet."
      );
    }

    // verify required parameter 'toTimestamp' is not null or undefined
    if (toTimestamp === null || toTimestamp === undefined) {
      throw new Error(
        "Required parameter toTimestamp was null or undefined when calling installationlocationIdPowerGet."
      );
    }

    if (fromTimestamp !== undefined) {
      localVarQueryParameters["fromTimestamp"] = ObjectSerializer.serialize(
        fromTimestamp,
        "string"
      );
    }

    if (toTimestamp !== undefined) {
      localVarQueryParameters["toTimestamp"] = ObjectSerializer.serialize(
        toTimestamp,
        "string"
      );
    }

    if (resolution !== undefined) {
      localVarQueryParameters["resolution"] = ObjectSerializer.serialize(
        resolution,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Readings }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Readings");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Update installation location
   * @summary Update installation location
   * @param id id of the InstallationLocation
   * @param installationLocation the updated installation location
   */
  public installationlocationIdPut(
    id: string,
    installationLocation: InstallationLocation
  ): Promise<{ response: http.ClientResponse; body: InstallationLocation }> {
    const localVarPath =
      this.basePath +
      "/installationlocation/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationlocationIdPut."
      );
    }

    // verify required parameter 'installationLocation' is not null or undefined
    if (installationLocation === null || installationLocation === undefined) {
      throw new Error(
        "Required parameter installationLocation was null or undefined when calling installationlocationIdPut."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        installationLocation,
        "InstallationLocation"
      )
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: InstallationLocation;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InstallationLocation");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get installation location readings. This splits up samples into individual arrays of their type. Date range should not be longer than a week.
   * @summary Get readings for an installation location
   * @param id id of the InstallationLocation
   * @param fromTimestamp ISO8601 timestamp (UTC)
   * @param toTimestamp ISO8601 timestamp (UTC)
   * @param milliseconds true if timestamps be returned in milliseconds. False will be returned in seconds. Default is false.
   */
  public installationlocationIdReadingsGet(
    id: string,
    fromTimestamp: string,
    toTimestamp: string,
    milliseconds?: boolean
  ): Promise<{ response: http.ClientResponse; body: Readings }> {
    const localVarPath =
      this.basePath +
      "/installationlocation/{id}/readings/".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationlocationIdReadingsGet."
      );
    }

    // verify required parameter 'fromTimestamp' is not null or undefined
    if (fromTimestamp === null || fromTimestamp === undefined) {
      throw new Error(
        "Required parameter fromTimestamp was null or undefined when calling installationlocationIdReadingsGet."
      );
    }

    // verify required parameter 'toTimestamp' is not null or undefined
    if (toTimestamp === null || toTimestamp === undefined) {
      throw new Error(
        "Required parameter toTimestamp was null or undefined when calling installationlocationIdReadingsGet."
      );
    }

    if (fromTimestamp !== undefined) {
      localVarQueryParameters["fromTimestamp"] = ObjectSerializer.serialize(
        fromTimestamp,
        "string"
      );
    }

    if (toTimestamp !== undefined) {
      localVarQueryParameters["toTimestamp"] = ObjectSerializer.serialize(
        toTimestamp,
        "string"
      );
    }

    if (milliseconds !== undefined) {
      localVarQueryParameters["milliseconds"] = ObjectSerializer.serialize(
        milliseconds,
        "boolean"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Readings }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Readings");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Get installation location samples. Date range should not be longer than a week
   * @summary Get samples for an installation location
   * @param id id of the InstallationLocation
   * @param fromTimestamp ISO8601 timestamp (UTC)
   * @param toTimestamp ISO8601 timestamp (UTC)
   */
  public installationlocationIdSamplesGet(
    id: string,
    fromTimestamp: string,
    toTimestamp: string
  ): Promise<{ response: http.ClientResponse; body: Array<Sample> }> {
    const localVarPath =
      this.basePath +
      "/installationlocation/{id}/samples/".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationlocationIdSamplesGet."
      );
    }

    // verify required parameter 'fromTimestamp' is not null or undefined
    if (fromTimestamp === null || fromTimestamp === undefined) {
      throw new Error(
        "Required parameter fromTimestamp was null or undefined when calling installationlocationIdSamplesGet."
      );
    }

    // verify required parameter 'toTimestamp' is not null or undefined
    if (toTimestamp === null || toTimestamp === undefined) {
      throw new Error(
        "Required parameter toTimestamp was null or undefined when calling installationlocationIdSamplesGet."
      );
    }

    if (fromTimestamp !== undefined) {
      localVarQueryParameters["fromTimestamp"] = ObjectSerializer.serialize(
        fromTimestamp,
        "string"
      );
    }

    if (toTimestamp !== undefined) {
      localVarQueryParameters["toTimestamp"] = ObjectSerializer.serialize(
        toTimestamp,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<Sample> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<Sample>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Gets the last sample received from this installation location
   * @summary Gets the last sample received from this installation location
   * @param id id of the InstallationLocation
   */
  public installationlocationIdSamplesLatestGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: Sample }> {
    const localVarPath =
      this.basePath +
      "/installationlocation/{id}/samples/latest".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling installationlocationIdSamplesLatestGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Sample }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Sample");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Create a new installation location
   * @summary Create new installation location
   * @param installationLocation the new object to create
   */
  public installationlocationPost(
    installationLocation: InstallationLocation
  ): Promise<{ response: http.ClientResponse; body: InstallationLocation }> {
    const localVarPath = this.basePath + "/installationlocation/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'installationLocation' is not null or undefined
    if (installationLocation === null || installationLocation === undefined) {
      throw new Error(
        "Required parameter installationLocation was null or undefined when calling installationlocationPost."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        installationLocation,
        "InstallationLocation"
      )
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: InstallationLocation;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InstallationLocation");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum PowerQApiApiKeys {
  JWT
}

export class PowerQApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: PowerQApiApiKeys, value: string) {
    (this.authentications as any)[PowerQApiApiKeys[key]].apiKey = value;
  }
  /**
   * Search for PowerQ
   * @summary Search for PowerQ
   * @param serialNumber serialNumber of powerQ to find
   */
  public powerqGet(
    serialNumber: string
  ): Promise<{ response: http.ClientResponse; body: Array<PowerQ> }> {
    const localVarPath = this.basePath + "/powerq";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'serialNumber' is not null or undefined
    if (serialNumber === null || serialNumber === undefined) {
      throw new Error(
        "Required parameter serialNumber was null or undefined when calling powerqGet."
      );
    }

    if (serialNumber !== undefined) {
      localVarQueryParameters["serialNumber"] = ObjectSerializer.serialize(
        serialNumber,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<PowerQ> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<PowerQ>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Get PowerQ by ID.
   * @summary Get PowerQ by ID
   * @param id ID of PowerQ
   */
  public powerqIdGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: PowerQ }> {
    const localVarPath =
      this.basePath +
      "/powerq/{id}".replace("{" + "id" + "}", encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling powerqIdGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: PowerQ }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "PowerQ");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum PowerQCircuitApiApiKeys {
  JWT
}

export class PowerQCircuitApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: PowerQCircuitApiApiKeys, value: string) {
    (this.authentications as any)[PowerQCircuitApiApiKeys[key]].apiKey = value;
  }
  /**
   * Search for PowerQCircuit
   * @summary Search for PowerQCircuit
   * @param powerqId ID of powerQ to find circuits for
   */
  public powerqcircuitGet(
    powerqId: string
  ): Promise<{ response: http.ClientResponse; body: Array<PowerQCircuit> }> {
    const localVarPath = this.basePath + "/powerqcircuit";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'powerqId' is not null or undefined
    if (powerqId === null || powerqId === undefined) {
      throw new Error(
        "Required parameter powerqId was null or undefined when calling powerqcircuitGet."
      );
    }

    if (powerqId !== undefined) {
      localVarQueryParameters["powerqId"] = ObjectSerializer.serialize(
        powerqId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<PowerQCircuit>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<PowerQCircuit>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get PowerQCircuit by ID.
   * @summary Get PowerQCircuit by ID
   * @param id ID of PowerQCircuit
   */
  public powerqcircuitIdGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: PowerQCircuit }> {
    const localVarPath =
      this.basePath +
      "/powerqcircuit/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling powerqcircuitIdGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: PowerQCircuit }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "PowerQCircuit");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Get latest reading from PowerQCircuit by ID.
   * @summary Get latest reading from PowerQCircuit
   * @param id ID of PowerQCircuit
   */
  public powerqcircuitIdLatestGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: Error }> {
    const localVarPath =
      this.basePath +
      "/powerqcircuit/{id}/latest".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling powerqcircuitIdLatestGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Error }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Error");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum UserApiApiKeys {
  JWT
}

export class UserApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: UserApiApiKeys, value: string) {
    (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
  }
  /**
   * Search for users
   * @summary Gets a list of users that the current user has visibilty of - (All the users in the organisation)
   * @param organisationId default is current organisation id.
   */
  public userGet(
    organisationId?: string
  ): Promise<{ response: http.ClientResponse; body: Array<unknown> }> {
    const localVarPath = this.basePath + "/user";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (organisationId !== undefined) {
      localVarQueryParameters["organisationId"] = ObjectSerializer.serialize(
        organisationId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<unknown> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<User>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Get a user
   * @summary Gets a user by is
   * @param id ID of the user to get
   */
  public userIdGet(
    id: string
  ): Promise<{ response: http.ClientResponse; body: unknown }> {
    const localVarPath =
      this.basePath +
      "/user/{id}".replace("{" + "id" + "}", encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling userIdGet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: unknown }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "User");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Update User
   * @summary Update User
   * @param id id of the User
   * @param user the updated user. Leave password blank if you don&#39;t want to update it
   */
  public userIdPut(
    id: string,
    user: UpdateUser
  ): Promise<{ response: http.ClientResponse; body: unknown }> {
    const localVarPath =
      this.basePath +
      "/user/{id}".replace("{" + "id" + "}", encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling userIdPut."
      );
    }

    // verify required parameter 'user' is not null or undefined
    if (user === null || user === undefined) {
      throw new Error(
        "Required parameter user was null or undefined when calling userIdPut."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(user, "UpdateUser")
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: unknown }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "User");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Get the current user
   * @summary Get the current user
   */
  public userMeGet(): Promise<{
    response: http.ClientResponse;
    body: unknown;
  }> {
    const localVarPath = this.basePath + "/user/me";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: unknown }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "User");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Create a new user. Will not be linked to this organisation until POST on UserOrganisation is done.
   * @summary Create a new user
   * @param user The new user to create.
   */
  public userPost(
    user: CreateUser
  ): Promise<{ response: http.ClientResponse; body: unknown }> {
    const localVarPath = this.basePath + "/user";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'user' is not null or undefined
    if (user === null || user === undefined) {
      throw new Error(
        "Required parameter user was null or undefined when calling userPost."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(user, "CreateUser")
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: unknown }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "User");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum UserOrganisationApiApiKeys {
  JWT
}

export class UserOrganisationApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWT: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: UserOrganisationApiApiKeys, value: string) {
    (this.authentications as any)[
      UserOrganisationApiApiKeys[key]
    ].apiKey = value;
  }
  /**
   * Search for UserOrganisations for the current organisation
   * @summary Search for UserOrganisations
   * @param organisationId default is current organisation id. Will only search in the context of the logged in user
   * @param userId search for a specific user
   */
  public userorganisationGet(
    organisationId?: string,
    userId?: string
  ): Promise<{ response: http.ClientResponse; body: Array<UserOrganisation> }> {
    const localVarPath = this.basePath + "/userorganisation/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (organisationId !== undefined) {
      localVarQueryParameters["organisationId"] = ObjectSerializer.serialize(
        organisationId,
        "string"
      );
    }

    if (userId !== undefined) {
      localVarQueryParameters["userId"] = ObjectSerializer.serialize(
        userId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<UserOrganisation>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<UserOrganisation>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Update a user role. User can only belong to a single organisation
   * @summary Update a user role
   * @param userOrg The new user/org with updated role. Organisation ID MUST be the current org id
   */
  public userorganisationPost(
    userOrg: UserOrganisation
  ): Promise<{ response: http.ClientResponse; body: UserOrganisation }> {
    const localVarPath = this.basePath + "/userorganisation/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'userOrg' is not null or undefined
    if (userOrg === null || userOrg === undefined) {
      throw new Error(
        "Required parameter userOrg was null or undefined when calling userorganisationPost."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(userOrg, "UserOrganisation")
    };

    this.authentications.JWT.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: UserOrganisation;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "UserOrganisation");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
